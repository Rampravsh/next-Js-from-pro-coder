<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Guide to Next.js Rendering Paradigms</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- Chosen Palette: Warm Neutrals with Slate Blue Accent -->
    <!-- Application Structure Plan: The application is designed as a single-page scrolling experience with a sticky top navigation for quick access. This structure is more intuitive than a multi-page or tabbed layout for a finite set of related topics. It starts with a general introduction, followed by detailed "cards" for each of the four paradigms (SSG, SSR, ISR, CSR). Each card has interactive toggles for "Pros" and "Cons" to reduce cognitive load and encourage user engagement. The application culminates in a dynamic comparison section where users can select different metrics (Performance, SEO, etc.) and toggle paradigms to visualize their relative strengths and weaknesses on a bar chart. This user-driven comparison is the core of the interactive experience, transforming a static document into an analytical tool that promotes deeper understanding and synthesis of the material. -->
    <!-- Visualization & Content Choices: 
        - Introduction: Report Info -> Overview of Next.js rendering. Goal -> Inform. Presentation -> Simple text block. Interaction -> None. Justification -> Sets the stage clearly.
        - Paradigm Details (x4): Report Info -> Detailed breakdown of each paradigm. Goal -> Organize & Inform. Presentation -> Individual "card" layouts using HTML/Tailwind. Interaction -> Toggle buttons for Pros/Cons. Justification -> Breaks down complex info into manageable, interactive chunks, making it less overwhelming than static lists.
        - Paradigm Comparison: Report Info -> Synthesized pros/cons of all paradigms. Goal -> Compare & Analyze. Viz Method -> Horizontal Bar Chart. Interaction -> Dropdown to select comparison metric (e.g., Performance, SEO) and checkboxes to toggle which paradigms are displayed. Justification -> This is the most effective way to visually compare multiple items across several quantitative/qualitative axes. It allows users to create their own comparisons, answering specific questions they might have. Library -> Chart.js (Canvas).
        - CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f8f7f4;
        color: #4a4a4a;
      }
      .chart-container {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin-left: auto;
        margin-right: auto;
        height: 400px;
        max-height: 50vh;
      }
      @media (min-width: 768px) {
        .chart-container {
          height: 500px;
        }
      }
      .nav-link {
        transition: color 0.3s ease;
      }
      .nav-link:hover {
        color: #435a7d;
      }
      .active-tab {
        background-color: #435a7d !important;
        color: #ffffff !important;
      }
    </style>
  </head>
  <body class="antialiased">
    <header class="bg-white/80 backdrop-blur-lg sticky top-0 z-50 shadow-sm">
      <nav class="container mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex items-center justify-between h-16">
          <div class="flex items-center">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800">
              Next.js Rendering
            </h1>
          </div>
          <div class="hidden md:block">
            <div class="ml-10 flex items-baseline space-x-4">
              <a
                href="#introduction"
                class="nav-link text-gray-600 px-3 py-2 rounded-md text-sm font-medium"
                >Home</a
              >
              <a
                href="#ssg"
                class="nav-link text-gray-600 px-3 py-2 rounded-md text-sm font-medium"
                >SSG</a
              >
              <a
                href="#ssr"
                class="nav-link text-gray-600 px-3 py-2 rounded-md text-sm font-medium"
                >SSR</a
              >
              <a
                href="#isr"
                class="nav-link text-gray-600 px-3 py-2 rounded-md text-sm font-medium"
                >ISR</a
              >
              <a
                href="#csr"
                class="nav-link text-gray-600 px-3 py-2 rounded-md text-sm font-medium"
                >CSR</a
              >
              <a
                href="#comparison"
                class="nav-link text-gray-600 px-3 py-2 rounded-md text-sm font-medium"
                >Compare</a
              >
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-8 md:py-12">
      <section id="introduction" class="text-center mb-16">
        <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4">
          An Interactive Guide to Rendering Paradigms
        </h2>
        <p class="max-w-3xl mx-auto text-lg text-gray-600">
          Next.js offers a variety of rendering strategies to optimize your
          React applications for performance, SEO, and user experience.
          Understanding the trade-offs of each paradigm is key to building fast,
          scalable, and efficient web applications. This guide provides an
          interactive way to explore and compare them.
        </p>
      </section>

      <div id="paradigms-container" class="space-y-12"></div>

      <section id="comparison" class="mt-20 pt-10 border-t border-gray-200">
        <div class="text-center mb-12">
          <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4">
            Paradigm Comparison Tool
          </h2>
          <p class="max-w-3xl mx-auto text-lg text-gray-600">
            Use the controls below to visually compare the rendering methods
            across different criteria. This tool helps illustrate the key
            trade-offs in performance, SEO, data freshness, and server
            efficiency.
          </p>
        </div>

        <div class="bg-white rounded-xl shadow-lg p-6 md:p-8">
          <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <div class="md:col-span-1">
              <label
                for="metric-selector"
                class="block text-sm font-medium text-gray-700 mb-2"
                >Comparison Metric:</label
              >
              <select
                id="metric-selector"
                class="w-full bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5"
              >
                <option value="performance">Performance (Load Speed)</option>
                <option value="seo">SEO Friendliness</option>
                <option value="dataFreshness">Data Freshness</option>
                <option value="serverEfficiency">Server Efficiency</option>
              </select>
            </div>
            <div class="md:col-span-2">
              <label class="block text-sm font-medium text-gray-700 mb-2"
                >Show Paradigms:</label
              >
              <div
                id="paradigm-toggles"
                class="flex flex-wrap items-center gap-4"
              ></div>
            </div>
          </div>
          <div class="chart-container">
            <canvas id="comparisonChart"></canvas>
          </div>
        </div>
      </section>
    </main>

    <footer class="bg-white mt-20 border-t">
      <div
        class="container mx-auto py-6 px-4 sm:px-6 lg:px-8 text-center text-gray-500"
      >
        <p>&copy; 2025 Interactive Learning. All rights reserved.</p>
      </div>
    </footer>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const paradigmData = {
          ssg: {
            id: "ssg",
            name: "Static Site Generation (SSG)",
            description:
              "Static Site Generation is the process of pre-rendering a page at build time. This means the HTML for the page is generated once when the application is built and then reused for every request.",
            howItWorks:
              "Next.js uses the `getStaticProps` function to fetch data at build time. The page is then rendered into a static HTML file that can be served directly from a CDN.",
            useCases: [
              "Blogs",
              "Marketing pages",
              "E-commerce product pages",
              "Documentation sites",
            ],
            pros: [
              {
                title: "Performance",
                text: "Extremely fast page loads as there is no server-side computation on request.",
              },
              {
                title: "SEO",
                text: "Excellent for search engine optimization as the content is fully rendered and available to crawlers immediately.",
              },
              {
                title: "Scalability",
                text: "Static files can be served from a CDN, making them highly scalable.",
              },
            ],
            cons: [
              {
                title: "Data Staleness",
                text: "Data is only updated when the application is rebuilt and redeployed.",
              },
            ],
          },
          ssr: {
            id: "ssr",
            name: "Server-Side Rendering (SSR)",
            description:
              "Server-Side Rendering generates the HTML for a page on each request. The server fetches the necessary data, renders the page to HTML, and sends it to the client, ensuring the page is always up-to-date.",
            howItWorks:
              "Next.js uses the `getServerSideProps` function to fetch data on every request. The server generates the HTML and then hydrates it with JavaScript on the client side.",
            useCases: [
              "Dashboards",
              "Stock tickers",
              "Social media feeds",
              "Personalized content",
            ],
            pros: [
              {
                title: "Fresh Data",
                text: "Pages are always rendered with the most current data.",
              },
              {
                title: "Good SEO",
                text: "The server provides a fully rendered HTML page to search engine crawlers.",
              },
            ],
            cons: [
              {
                title: "Slower Load Times",
                text: "Can be slower than SSG as the server has to process the request and render the page on the fly.",
              },
              {
                title: "Higher Server Load",
                text: "Each request requires server resources, which can be a scalability concern.",
              },
            ],
          },
          isr: {
            id: "isr",
            name: "Incremental Static Regeneration (ISR)",
            description:
              "ISR is a hybrid approach that provides the benefits of static sites with the flexibility of server-rendered pages. It enables static pages to be updated after they have been deployed, without needing a full rebuild.",
            howItWorks:
              "ISR also uses `getStaticProps`, but with an added `revalidate` property. This property sets a time limit (in seconds) after which a page can be regenerated in the background. If a request comes in for a stale page, the old page is served while a new version is built.",
            useCases: [
              "News articles",
              "Product listings with dynamic pricing",
              "Event pages",
              "Comment sections",
            ],
            pros: [
              {
                title: "Fast Load Times",
                text: "Visitors are served a static page, ensuring speed.",
              },
              {
                title: "Data Freshness",
                text: "Content can be updated automatically without a full rebuild.",
              },
              {
                title: "Scalability",
                text: "Combines the benefits of static hosting with automatic updates.",
              },
            ],
            cons: [
              {
                title: "Initial Stale Content",
                text: "A user might briefly see a stale version of the page while the new one is being generated in the background.",
              },
            ],
          },
          csr: {
            id: "csr",
            name: "Client-Side Rendering (CSR)",
            description:
              "Client-Side Rendering is the traditional method where the browser downloads a minimal HTML shell and then uses JavaScript to fetch data and build the page content entirely on the client side.",
            howItWorks:
              "The initial page load is a simple HTML file. Next.js does not have a dedicated data fetching function for this, but data is typically fetched using the `useEffect` hook in React.",
            useCases: [
              "Web applications",
              "Personalized dashboards",
              "Admin panels",
              "Pages behind a login",
            ],
            pros: [
              {
                title: "Fast Initial Shell Load",
                text: "The initial HTML is very small and loads quickly.",
              },
              {
                title: "Reduced Server Load",
                text: "Most of the rendering work is offloaded to the client.",
              },
              {
                title: "Rich Interactivity",
                text: "Ideal for complex, application-like user interfaces.",
              },
            ],
            cons: [
              {
                title: "Poor SEO",
                text: "Search engine crawlers may not be able to fully index the content as it is not present in the initial HTML.",
              },
              {
                title: "Slower First Contentful Paint",
                text: "The user has to wait for JavaScript to execute and fetch data before seeing the full page content.",
              },
            ],
          },
        };

        const comparisonMetrics = {
          performance: {
            label: "Performance (Higher is Better)",
            values: { ssg: 10, ssr: 6, isr: 9, csr: 4 },
          },
          seo: {
            label: "SEO Friendliness (Higher is Better)",
            values: { ssg: 10, ssr: 9, isr: 10, csr: 3 },
          },
          dataFreshness: {
            label: "Data Freshness (Higher is Better)",
            values: { ssg: 2, ssr: 10, isr: 7, csr: 9 },
          },
          serverEfficiency: {
            label: "Server Efficiency (Higher is Better)",
            values: { ssg: 10, ssr: 4, isr: 9, csr: 8 },
          },
        };

        const colors = {
          ssg: "rgba(75, 192, 192, 0.6)",
          ssr: "rgba(255, 99, 132, 0.6)",
          isr: "rgba(54, 162, 235, 0.6)",
          csr: "rgba(255, 206, 86, 0.6)",
        };
        const borderColors = {
          ssg: "rgba(75, 192, 192, 1)",
          ssr: "rgba(255, 99, 132, 1)",
          isr: "rgba(54, 162, 235, 1)",
          csr: "rgba(255, 206, 86, 1)",
        };

        const container = document.getElementById("paradigms-container");
        for (const key in paradigmData) {
          const data = paradigmData[key];
          const card = `
                    <section id="${
                      data.id
                    }" class="bg-white rounded-xl shadow-lg p-6 md:p-8 scroll-mt-20">
                        <h3 class="text-2xl md:text-3xl font-bold text-gray-900 mb-2">${
                          data.name
                        }</h3>
                        <p class="text-gray-600 mb-6">${data.description}</p>
                        
                        <div class="mb-6">
                            <h4 class="font-semibold text-lg text-gray-800 mb-2">How It Works</h4>
                            <p class="text-gray-600 bg-gray-50 p-4 rounded-lg border border-gray-200">${
                              data.howItWorks
                            }</p>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                            <div>
                                <h4 class="font-semibold text-lg text-gray-800 mb-3">Ideal Use Cases</h4>
                                <ul class="list-disc list-inside space-y-2 text-gray-600">
                                    ${data.useCases
                                      .map((uc) => `<li>${uc}</li>`)
                                      .join("")}
                                </ul>
                            </div>
                             <div>
                                <div class="flex border border-gray-200 rounded-lg p-1 bg-gray-50 mb-4">
                                    <button data-type="pros" data-paradigm="${
                                      data.id
                                    }" class="pros-cons-btn flex-1 p-2 text-sm font-medium rounded-md active-tab">Advantages</button>
                                    <button data-type="cons" data-paradigm="${
                                      data.id
                                    }" class="pros-cons-btn flex-1 p-2 text-sm font-medium rounded-md">Disadvantages</button>
                                </div>
                                <div id="content-${
                                  data.id
                                }" class="space-y-3"></div>
                            </div>
                        </div>
                    </section>
                `;
          container.innerHTML += card;
        }

        function renderProsCons(paradigmId, type) {
          const contentDiv = document.getElementById(`content-${paradigmId}`);
          const data = paradigmData[paradigmId][type];
          const isPros = type === "pros";
          contentDiv.innerHTML = data
            .map(
              (item) => `
                    <div class="p-3 rounded-md ${
                      isPros
                        ? "bg-green-50 border-green-200"
                        : "bg-red-50 border-red-200"
                    } border">
                        <p class="font-semibold ${
                          isPros ? "text-green-800" : "text-red-800"
                        }">${item.title}</p>
                        <p class="text-sm ${
                          isPros ? "text-green-700" : "text-red-700"
                        }">${item.text}</p>
                    </div>
                `
            )
            .join("");
        }

        document.querySelectorAll(".pros-cons-btn").forEach((button) => {
          button.addEventListener("click", () => {
            const { paradigm, type } = button.dataset;
            document
              .querySelectorAll(`.pros-cons-btn[data-paradigm="${paradigm}"]`)
              .forEach((btn) => btn.classList.remove("active-tab"));
            button.classList.add("active-tab");
            renderProsCons(paradigm, type);
          });
        });

        Object.keys(paradigmData).forEach((key) => renderProsCons(key, "pros"));

        const togglesContainer = document.getElementById("paradigm-toggles");
        let visibleParadigms = new Set(Object.keys(paradigmData));

        Object.keys(paradigmData).forEach((key) => {
          const data = paradigmData[key];
          const toggle = `
                    <div class="flex items-center">
                        <input id="toggle-${
                          data.id
                        }" type="checkbox" checked class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 paradigm-toggle" data-paradigm="${
            data.id
          }">
                        <label for="toggle-${
                          data.id
                        }" class="ml-2 block text-sm text-gray-900">${
            data.name.split(" (")[0]
          }</label>
                    </div>
                `;
          togglesContainer.innerHTML += toggle;
        });

        const ctx = document.getElementById("comparisonChart").getContext("2d");
        let comparisonChart = new Chart(ctx, {
          type: "bar",
          data: { datasets: [] },
          options: {
            indexAxis: "y",
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { beginAtZero: true, max: 10, grid: { color: "#e5e7eb" } },
              y: { grid: { display: false } },
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    let label = context.dataset.label || "";
                    if (label) {
                      label += ": ";
                    }
                    if (context.parsed.x !== null) {
                      label += context.parsed.x + " / 10";
                    }
                    return label;
                  },
                },
              },
            },
          },
        });

        function updateChart() {
          const selectedMetric =
            document.getElementById("metric-selector").value;
          const metricData = comparisonMetrics[selectedMetric];

          comparisonChart.data.labels = Array.from(visibleParadigms).map(
            (p) => paradigmData[p].name
          );
          comparisonChart.data.datasets = [
            {
              label: metricData.label,
              data: Array.from(visibleParadigms).map(
                (p) => metricData.values[p]
              ),
              backgroundColor: Array.from(visibleParadigms).map(
                (p) => colors[p]
              ),
              borderColor: Array.from(visibleParadigms).map(
                (p) => borderColors[p]
              ),
              borderWidth: 1,
            },
          ];

          comparisonChart.options.scales.x.title.text = metricData.label;
          comparisonChart.update();
        }

        document
          .getElementById("metric-selector")
          .addEventListener("change", updateChart);

        document.querySelectorAll(".paradigm-toggle").forEach((toggle) => {
          toggle.addEventListener("change", () => {
            const { paradigm } = toggle.dataset;
            if (toggle.checked) {
              visibleParadigms.add(paradigm);
            } else {
              visibleParadigms.delete(paradigm);
            }
            updateChart();
          });
        });

        updateChart();
      });
    </script>
  </body>
</html>
